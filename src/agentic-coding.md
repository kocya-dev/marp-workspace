# Agentic Coding

## point

- 何を作成したか、何故作成したか
- 前提
- どのように作成したか
- 実プロダクトへの展開
- 作成のポイント
- その他

## 前提

### Overview

AI を最大限活用するには、適切なコンテキストを与え、コンテキストウィンドウを超えないようタスクを分割することをが重要である。
また、AI の出力を狙った形に仕向けるためのガードレールの整備が必要である。

### 背景

AI への指示がうまくいかない場合ケース

- 適切な情報が与えられていない
  - コンテキストをどのようにして伝えるか
- 情報過多でコンテキストウィンドウを超えてしまう
  - タスクの分割と継続をどのように指示するか
- AI の出力が狙った形にならない
  - ガードレールをどのように整備するか

### 適切な情報が与えられていない > コンテキストをどのようにして伝えるか

GitHub Copilot の機能を利用して、プロジェクト内で一貫したコンテキストを与える。

- `.github/copilot-instructions.md`
  - 全てのプロンプトに共通する指示
    - プロジェクトに共通する背景、ルール
    - 全てにおいて適用される仕様
    - 指示や回答、プロセスに関するルール
- `.github/instructions/*.instructions.md`
  - パスごとに異なる指示
    - ディレクトリ構造でモジュール分割しており、モジュールごとに必要なドメイン知識が異なる場合
    - 特定の拡張子に対して特有の指示が必要な場合

※`*.instructions.md` は、VSCode の設定でディレクトリ指定可能

### 情報過多でコンテキストウィンドウを超えてしまう > コンテキスト入力や分割の工夫例

コンテキストウィンドウを溢れないように、タスクを分割して継続的に指示する。

- Cline (Roo Code)
  - Orchestration Mode によるタスク分割
- Claude Code
  - Prompt Chaining によるプロンプト分割時の情報の受け渡し
  - Plan mode の存在
- Devin
  - 指示を受けた後の Planning

こうしたツールの機能・特性をまとめると、重要なポイントは下記の通り。

- 計画の作成
- 計画の分割
- 作業進行状況の管理

### AI の出力が狙った形にならない > AI の出力を狙った形に仕向けるためのガードレール

- linter, unit test
- AI の作業への完成基準の設定

### GitHub Copilot の Agentic Coding に必要なもの

- 計画作成、分割、作業進行状況の管理を行う
- ガードレールの整備

### コンテキストエンジニアリング

AI は入力された情報を元に応答を生成する。
従来は入力情報の工夫という観点で、プロンプトエンジニアリングが注目されていた。
現在はより大規模なコードベースに対して多くの作業を AI に任せるようになり、AI が必要とする情報を適切な形式で、適切なタイミングに提供する仕組みの設計が重要になってきている。

以下、Google Philipp Schmid 氏の言葉より

> コンテキストエンジニアリングを「AI が必要とする情報を、適切な形式で、適切なタイミングに提供する仕組みの設計」と位置付ける

具体的に…

- ★System Prompt（AI のシステム的前提）
- User Prompt（ユーザーからの指示）→ 従来のプロンプトエンジニアリングの領域
- ★State/History（対話履歴や状態管理）
- ★Long-Term Memory（長期記憶としての知識）
- Retrieved Information（RAG などによる検索情報） → MCP
- Tools/Structured Output（外部ツール連携・構造化出力) → MCP

## どのように作成したか

### 流れ

- spec を整備
- custom-instructions を整備
  - `.github/copilot-instructions.md`
  - `.github/instructions/*.instructions.md`
- planning
- 指示
- 動作確認
- 仕様変更

### 実例

- ディレクトリ構造
- カスタムインストラクション
- 計画書

### うまくできなかったポイント

- UI 周り
- Playwright でなんとかならないか？

## 実プロダクトへの展開

### 気を付けるポイント

コード量も多く、仕様も複雑。どのように進めるか？

- ディレクトリ構造単位でのルール整備
- 開発者の環境ごとの整備 (win, mac)は.gitignore でコミットから除外したカスタムルールで定義
- ある程度細かいタスクでの活用。
- 既存コードベースがあるので参照先を指示
- リポジトリ上にある仕様書を参照させる。
- ローカルで先に確認したいのでコミットまで。PR 発行はその後で。
- それでも失敗はある。ルールの定義、計画の修正、成果物の確認では技術力が必要になる。

### 実例

- 変更例とやりとりの例

## 作成のポイント

### まとめ

- ルールを整備する
  - .github/copilot-instructions.md
    - プロジェクトの背景、ルール、仕様、指示や回答のルールを明確化
    - (今回は小規模だったので)仕様書を常に参照するよう記載
  - .github/instructions/\*.instructions.md
    - ロジックの実装とテストの実装でルールを分割、不要なコンテキスト入力を避ける
- ガードレールを整備する
  - lint/formatter/unittest の整備
    - コードの品質を保つためのガードレールを整備
- タスクの分割と継続的な指示
  - タスクを分割しコンテキストを適切なサイズに収めつつ、
    複数の指示で一貫性のあるコンテキスト入力を行う
- Copilot に道具を与える
  - GitHub CLI をインストールしてコミットや PR 作成も任せる

### 補助機能の説明

- カスタムインストラクションの作成補助
- Allow/Deny List

## その他

- AI を活用しやすい設計、ディレクトリ構造、アーキテクチャ
  - モノリス、マイクロサービス、モジュラーモノリス
  - ドキュメントの markdown 化と管理場所の統一
- 開発対象の特性に合わせた適用範囲の調整

## 最後に

- 広告
